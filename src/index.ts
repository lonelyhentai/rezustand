import { createContext, createElement, useContext, useRef } from 'react';
import type { Context, PropsWithChildren, Provider } from 'react';
import type { Draft } from 'immer';
import { useStore } from 'zustand';
import type { StoreApi } from 'zustand';
import { immer } from 'zustand/middleware/immer';
import type { ExtractState, IsVoid } from './type-utils';

export type StoreEasySetStateType<T> = {
  (s: Partial<T> | T, shouldReplace?: boolean | undefined): T;
  // infer that can not return any value when use as draft<T>
  <R extends IsVoid<R>>(
    f: (s: Draft<T>) => R,
    shouldReplace?: boolean | undefined
  ): void;
};

export type StoreEasyCreateOptions<T> = {
  setup(): T;
} & ThisType<{
  get: () => Readonly<T>;
  set: StoreEasySetStateType<T>;
  methods: {
    readonly [key in keyof T as T[key] extends (...args: any[]) => any
      ? key
      : never]: T[key];
  };
}>;

export function easyCreator<T>(createOptions: StoreEasyCreateOptions<T>) {
  return (set: any, get: any) => {
    const obj = {
      get,
      set,
      get methods() {
        return this.get();
      },
      setup() {
        return createOptions.setup.call(this);
      },
    };
    return obj.setup();
  };
}

export function easyImmer<T>(createOptions: StoreEasyCreateOptions<T>) {
  return immer(easyCreator(createOptions));
}

export function easyStoreProvider<P, S extends StoreApi<any>>(
  createStore: (props: P) => S,
  context: Context<S | null>
) {
  return function EasyStoreProvider(props: PropsWithChildren<P>) {
    const storeRef = useRef<ReturnType<typeof createStore> | null>(null);
    if (!storeRef.current) {
      storeRef.current = createStore(props);
    }
    return createElement(
      context.Provider as any as Provider<S>,
      { value: storeRef.current as S },
      props.children
    );
  };
}

export function easyStoreContext<S extends StoreApi<any>, P>(
  createStore: (props: P) => S
) {
  type t = EasyInferStoreTypes<typeof createStore>;
  const StoreContext = createContext<S | null>(null);

  const useContextStore = ((...args: any[]) => {
    const contextStore = useContext(StoreContext);
    if (!contextStore) {
      throw new Error(
        `there has no context store generated by ${
          createStore.name ?? createStore.toString()
        }`
      );
    }
    // @ts-expect-error force convert types
    return useStore(contextStore, ...args);
  }) as t['UseContextStoreType'];

  const StoreProvider = easyStoreProvider(createStore, StoreContext);

  return {
    useContextStore,
    StoreContext,
    StoreProvider,
  };
}

export type EasyInferStoreTypes<
  CreateStore extends (props: any) => StoreApi<any>
> = CreateStore extends (props: infer P) => infer S
  ? {
      CreateStorePropsType: P;
      CreateStoreType: CreateStore;
      StoreType: S;
      ContextType: Context<S | null>;
      ProviderType: Provider<S>;
      UseContextStoreType: {
        (): ExtractState<S>;
        <U>(
          selector: (state: ExtractState<S>) => U,
          equals?: (a: U, b: U) => boolean
        ): U;
      };
    }
  : never;
